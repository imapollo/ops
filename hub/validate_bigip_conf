#!/usr/bin/perl
#
# Validate the BIG-IP configurations for specified environment.
# Following items will be checked:
#  - Check if VIPs point to correct Pool.
#  - Check if VIPs using correct iRule.
#  - Check if any missing/extra VIPs.
#  - Check if VIPs DNS/IP is correct.
#  - Check if Pools DNS/IP is correct.
#  - Check if any missing/extra Pool.
#
# Usage: validate_bigip_conf [options]
#
# Options:
#  -e | --env               Specify the environment ID. For example: srwd76.
#  -b | --branch            Specify the branch to check based on.
#                           Default: main.
#  -v | --verbose           Show verbose messages.
#  -h | --help              Show help information.
#
# Examples:
#  validate_bigip_conf -e srwd76
#  validate_bigip_conf -e srwd76 -b rb_ecomm_13_13
#
# Author: minjzhang
#

use strict;
use warnings;

use lib '/nas/reg/lib/perl';
# use lib '/nas/utl/devops/lib/perl';
use lib '/nas/home/minjzhang/ops/util/lib';

use Readonly;
use Getopt::Long;
use Data::Dumper;
use File::Temp;

use Stubhub::BigIP::System::Util qw (
                                    get_icontrol
                                );
use Stubhub::BigIP::Pool::Handler qw (
                                    get_env_pool_list
                                );
use Stubhub::BigIP::Pool::ConfigGenerator qw (
                                    generate_pool_separate_configs
                                );
use Stubhub::BigIP::Pool::Parser qw (
                                    parse_pools
                                );
use Stubhub::BigIP::Virtual::Handler qw (
                                    get_env_virtual_servers
                                    get_vs_default_pool
                                    get_vs_irules
                                );
use Stubhub::BigIP::Virtual::ConfigGenerator qw (
                                    generate_vs_separate_configs
                                );
use Stubhub::BigIP::Virtual::Parser qw (
                                    parse_virtual_servers
                                );
use Stubhub::P4::Info qw (
                                    get_p4_branch_path
                                );
use Stubhub::P4::Client qw (
                                    check_out_perforce_file
                                    clean_perforce_client
                                );
use Stubhub::P4::Constants;
use Stubhub::Log::Util qw (
                                    init
                                    get_logger
                                    get_logger_with_loglevel
                                );

# Get options
my $show_usage = qw{};
my $show_verbose= qw{};
my $envid = qw{};
my $branch = "main";
my $options_okay = GetOptions (
   'e|env=s'     => \$envid,
   'b|branch=s'  => \$branch,
   'v|verbose'   => \$show_verbose,
   'h|help'      => \$show_usage,
);

Stubhub::Log::Util->init();
our $logger = get_logger_with_loglevel( $show_verbose );

#
# Signal Handler
#
$SIG{'INT'} = \&sigIntHandler;

#
# Clean up and exit when catch SIGINT(2)
#
sub sigIntHandler {
    exit;
}

if ( $show_usage ) {
    usage();
    exit 0;
}

#
# Usage
#
sub usage {
   print <<END_OF_HELP

END_OF_HELP
}

#
# Parameter validation
#
if ( ! defined $envid ) {
    print "Error: The pamameter '-e' must be set.\n";
    usage();
    exit 1;
}

#
# Get the expected virtual server list from P4.
#
sub get_expected_vs_list {
    my ( $vs_configuration_dir ) = @_;
    my $virtual_servers_ref = parse_virtual_servers( $vs_configuration_dir );
    my @expected_vs_list;
    foreach my $virtual_server_name ( keys %{ $virtual_servers_ref } ) {
        push @expected_vs_list, $virtual_server_name;
    }
    return @expected_vs_list;
}

#
# Get the expected pool list from P4.
#
sub get_expected_pool_list {
    my ( $pool_configuration_dir ) = @_;
    my $pools_ref = parse_pools( $pool_configuration_dir );
    my @expected_pool_list;
    foreach my $pool_name ( keys %{ $pools_ref } ) {
        push @expected_pool_list, $pool_name;
    }
    return @expected_pool_list;
}

#
# Compare 2 list.
# Return: \@match_list, \@extra_list, \@missing_list
#
sub compare_list {

    my ( $list1_ref, $list2_ref ) = @_;

    my %hash1 = map { $_ => 1 } @{ $list1_ref };
    my %hash2 = map { $_ => 1 } @{ $list2_ref };

    my @match_list;
    my @extra_list;
    my @missing_list;

    foreach my $env_vs ( keys %hash1 ) {
        if ( exists( $hash2{ $env_vs } ) ) {
            delete $hash2{ $env_vs };
            push @match_list, $env_vs;
        } else {
            push @extra_list, $env_vs;
        }
    }
    foreach my $expected_vs ( keys %hash2 ) {
        push @missing_list, $expected_vs;
    }

    return ( \@match_list, \@extra_list, \@missing_list );
}

#
# Validate the virtual server list based on templates on P4.
#
sub validate_vs_list {
    my ( $env_vs_list_ref, $expected_vs_list_ref ) = @_;

    my ( $match_vs_list_ref, $env_extra_list_ref, $env_missing_list_ref ) = compare_list( $env_vs_list_ref, $expected_vs_list_ref );

    if ( scalar @{ $env_extra_list_ref } > 0 ) {
        $logger->warn("Following virtual servers are not included in templates:");
        $logger->warn( join ",", @{ $env_extra_list_ref } );
        $logger->warn("");
    }
    if ( scalar @{ $env_missing_list_ref } > 0 ) {
        $logger->warn("Following virtual servers are missing:");
        $logger->warn( join ",", @{ $env_missing_list_ref } );
        $logger->warn("");
    }

    return @{ $match_vs_list_ref };
}

#
# Validate the pool list based on templates on P4.
#
sub validate_pool_list {
    my ( $env_pool_list_ref, $expected_pool_list_ref ) = @_;

    my ( $match_pool_list_ref, $env_extra_list_ref, $env_missing_list_ref ) = compare_list( $env_pool_list_ref, $expected_pool_list_ref );

    if ( scalar @{ $env_extra_list_ref } > 0 ) {
        $logger->warn("Following pools are not included in templates:");
        $logger->warn( join ",", @{ $env_extra_list_ref } );
        $logger->warn("");
    }
    if ( scalar @{ $env_missing_list_ref } > 0 ) {
        $logger->warn("Following pools are missing:");
        $logger->warn( join ",", @{ $env_missing_list_ref } );
        $logger->warn("");
    }

    return @{ $match_pool_list_ref };
}

#
# Validate virtual server configurations.
# - Check if virtual server is pointed to correct Pool.
# - Check if virtual server is using correct iRule.
# - Check if virtual server DNS/IP is correct.
#
sub validate_vs_conf {
    my ( $match_vs_list_ref, $env_vs_list_ref, $icontrol, $vs_configuration_dir ) = @_;
    my $expected_vs_ref = parse_virtual_servers( $vs_configuration_dir );
    foreach my $match_vs ( @{ $match_vs_list_ref } ) {
        my $expected_default_pool = $expected_vs_ref->{ $match_vs }{ 'default_pool' };
        my $expected_irule = $expected_vs_ref->{ $match_vs }{ 'irule' };

        my $match_vs_real_name;
        my $real_default_pool;
        my $real_irule;

        foreach my $env_vs ( @{ $env_vs_list_ref } ) {
            if ( $match_vs =~ /^$env_vs$/i ) {
                $match_vs_real_name = $env_vs;
                $real_default_pool = get_vs_default_pool( $icontrol, $env_vs);
                $real_default_pool = qw{} if $real_default_pool eq "";
                $real_irule = join ",", sort( get_vs_irules( $icontrol , $env_vs ) ) if ( scalar get_vs_irules( $icontrol, $env_vs ) > 0 );
                last;
            }
        }

        # Validate if matching.
        if ( ( defined $real_default_pool and defined $expected_default_pool )
                and ( $real_default_pool ne $expected_default_pool ) ) {
            $logger->warn( "The virtual server $match_vs_real_name default pool is expected as $expected_default_pool, but $real_default_pool.\n" );
        } elsif ( defined $real_default_pool and not defined $expected_default_pool ) {
            $logger->warn( "Default pool for $match_vs_real_name is $real_default_pool, but not defined in template." );
        } elsif ( not defined $real_default_pool and defined $expected_default_pool ) {
            $logger->warn( "Default pool for $match_vs_real_name should be $expected_default_pool, but not set instead." );
        }

        if ( ( defined $real_irule and defined $expected_irule ) 
                and ( $real_irule ne $expected_irule ) ) {
            $logger->warn( "The virtual server $match_vs_real_name irule is epected as $expected_irule, but $real_irule" );
        } elsif ( defined $real_irule and not defined $expected_irule ) {
            $logger->warn( "iRule for $match_vs_real_name is $real_irule, but not defined in template.");
        } elsif ( not defined $real_irule and defined $expected_irule ) {
            $logger->warn( "iRule for $match_vs_real_name should be $expected_irule, but not set instead.");
        }
    }
}

#
# Validate pool configurations.
# - Check if pool DNS/IP is correct.
#
sub validate_pool_conf {
}

#
# Get the BIGIP templates from P4 depot.
#
sub get_bigip_templates {
    my ( $branch ) = @_;
    my $p4_branch_path = get_p4_branch_path( $branch );
    my ( $dynamic_p4_client, $dynamic_p4_dir ) = check_out_perforce_file( "/$p4_branch_path/$Stubhub::P4::Constants::BIGIP_TEMPLATE_SUBDIR/..." );
    return ( $dynamic_p4_client, $dynamic_p4_dir, $p4_branch_path );
}

#
# Main
#
my ( $internal_ic, $external_ic ) = get_icontrol( $envid );
my %icontrols = (
    'int' => $internal_ic,
    'ext' => $external_ic
);

my ( $dynamic_p4_client, $dynamic_p4_dir, $p4_branch_path ) = get_bigip_templates( $branch );

foreach my $ic_key ( keys %icontrols ) {

    # Generate the configuration files based on templates on P4.
    my $vs_output_dir = File::Temp->newdir();
    my $pool_output_dir = File::Temp->newdir();
    generate_vs_separate_configs( "${dynamic_p4_dir}${p4_branch_path}/$Stubhub::P4::Constants::BIGIP_TEMPLATE_SUBDIR/$Stubhub::P4::Constants::BIGIP_VS_SUBDIR/$ic_key", $envid, $vs_output_dir );
    generate_pool_separate_configs( "${dynamic_p4_dir}${p4_branch_path}/$Stubhub::P4::Constants::BIGIP_TEMPLATE_SUBDIR/$Stubhub::P4::Constants::BIGIP_POOL_SUBDIR/$ic_key", $envid, $pool_output_dir );

    my @env_vs_list = get_env_virtual_servers( $icontrols{ $ic_key }, $envid );
    # lowercase all the virtual server name for consistency
    $_ = lc for @env_vs_list;
    my @env_expected_vs_list = get_expected_vs_list( $vs_output_dir );
    my @env_pool_list = get_env_pool_list( $icontrols{ $ic_key }, $envid );
    # uppercase all the virtual server name for consistency
    $_ = uc for @env_pool_list;
    my @env_expected_pool_list = get_expected_pool_list( $pool_output_dir );

    my @match_vs_list = validate_vs_list( \@env_vs_list, \@env_expected_vs_list );
    my @match_pool_list = validate_pool_list( \@env_pool_list, \@env_expected_pool_list );

    @env_vs_list = get_env_virtual_servers( $icontrols{ $ic_key }, $envid );
    @env_pool_list = get_env_pool_list( $icontrols{ $ic_key }, $envid );
    validate_vs_conf( \@match_vs_list, \@env_vs_list, $icontrols{ $ic_key }, $vs_output_dir);
    validate_pool_conf( \@match_pool_list, \@env_pool_list, $icontrols{ $ic_key }, $pool_output_dir);
}

clean_perforce_client( $dynamic_p4_client, $dynamic_p4_dir );

exit 0;
