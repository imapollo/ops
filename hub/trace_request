#!/usr/bin/perl
#
# Trace the request to determine which back-end server really
# getting the request. The script will determine the back-end
# server with following rules:
# - Based on the request path and irule if bond to virtual server.
# - Based on the default pool if no irule bond or path not found.
# - Based on the forward rule if going to API gateway.
#
# Usage: trace_request [options]
#
# Options:
#  -u | --url               Request the url. Default protocol: http.
#  -e | --envid             Specify the environment Id if necessary.
#  -v | --verbose           Show verbose messages.
#  -h | --help              Show help information.
#
# Examples:
#  trace_request -u api.srwd83.com
#  trace_request -u https://payment.api.srwd83.com/paymentapi/ccping
#  trace_request -u https://api-dev.srwd10.com/paymentapi -e srwd83
#
# Author: minjzhang
#

use strict;
use warnings;
use Carp;
use Getopt::Long;

# use lib '/nas/utl/devops/lib/perl';
use lib '/nas/home/minjzhang/ops/util/lib';
use lib '/nas/reg/lib/perl';

use JSON;
use Stubhub::Log::Util qw (
                            init
                            get_logger_with_loglevel
                        );
use Stubhub::BigIP::System::Util qw (
                            get_icontrol
                            get_special_icontrol
                        );
use Stubhub::BigIP::Virtual::Handler qw (
                            get_env_virtual_servers
                            get_vss_destinations
                            get_vs_irules
                            get_vs_default_pool
                        );
use Stubhub::BigIP::Pool::Handler qw (
                            get_env_pool_members
                        );
use Stubhub::BigIP::Rule::Handler qw (
                            get_rule_definition
                        );
use Stubhub::Util::Host qw (
                            get_ip_by_hostname
                            get_hostname_by_ip
                        );

# Get options
my $show_usage = qw{};
my $show_verbose = qw{};
my $request_url = qw{};
my $envid = qw{};
my $options_okay = GetOptions (
    'u|url=s'     => \$request_url,
    'e|envid=s'   => \$envid,
    'v|verbose'   => \$show_verbose,
    'h|help'      => \$show_usage,
);

#
# Initiate log instance
#
Stubhub::Log::Util->init();
our $logger = get_logger_with_loglevel( $show_verbose );

#
# Signal Handler
#
$SIG{'INT'} = \&sigIntHandler;

#
# Clean up and exit when catch SIGINT(2)
#
sub sigIntHandler {
    exit;
}

if ( $show_usage ) {
    usage();
    exit 0;
}

#
# Usage
#
sub usage {
    print <<END_OF_HELP

Trace the request to determine which back-end server really
getting the request. The script will determine the back-end
server with following rules:
- Based on the request path and irule if bond to virtual server.
- Based on the default pool if no irule bond or path not found.
- Based on the forward rule if going to API gateway.

Usage: trace_request [options]

Options:
 -u | --url               Request the url. Default protocol: http.
 -e | --envid             Specify the environment Id if necessary.
 -v | --verbose           Show verbose messages.
 -h | --help              Show help information.

Examples:
 trace_request -u api.srwd83.com
 trace_request -u https://payment.api.srwd83.com/paymentapi/ccping
 trace_request -u https://api-dev.srwd10.com/paymentapi -e srwd83

END_OF_HELP
}

#
# Parameter validation
#
if ( ! defined $request_url ) {
    $logger->error( "The pamameter '-u' must be set.\n" );
    usage();
    exit 1;
}

#
# Find the vritual server based on the request.
#
sub find_virtual_server {
    my ( $icontrols_ref, $envid, $protocol, $virtual_server ) = @_;

    my $virtual_server_ip = get_ip_by_hostname( $virtual_server );
    $protocol = "80" if $protocol eq "http";
    $protocol = "443" if $protocol eq "https";

    my $virtual_server_name = qw{};
    my $selected_icontrol;

    foreach my $icontrol ( @{ $icontrols_ref } ) {
        my @virtual_servers = get_env_virtual_servers( $icontrol, $envid);
        my @destinations = get_vss_destinations( $icontrol, @virtual_servers );
        my $vs_index = 0;
        foreach my $destination ( @destinations ) {
            if ( $destination->{ 'address' } eq $virtual_server_ip
                && $destination->{ 'port' } eq $protocol ) {
                $virtual_server_name = $virtual_servers[ $vs_index ];
                $selected_icontrol = $icontrol;
                last;
            }
            $vs_index = $vs_index + 1;
        }
        last if $virtual_server_name ne "";
    }
    return ( $selected_icontrol, $virtual_server_name );
}

#
# Parse the irule and get which pool is redirected to.
#
sub parse_irule {
    my ( $icontrol, $irules_on_f5_ref, $url_path ) = @_;
    foreach my $rule ( @{ $irules_on_f5_ref } ) {
        my $rule_definition = get_rule_definition( $icontrol, $rule ) . "\n";
        $logger->debug( "[iRule] definition for $rule" );
        $logger->debug( "\n$rule_definition" );
        my @rule_lines = split "\n", $rule_definition;
        my $match_rule = 0;
        my $go_pool = qw{};
        foreach my $rule_line ( @rule_lines ) {
            if ( $rule_line =~ /^\s*"\/.+"/ ) {
                $rule_line =~ s/^\s*"*(\/.+)".*/$1/;
                $rule_line =~ s/\*+$//;
                if ( $url_path =~ "$rule_line" ) {
                    $match_rule = 1;
                }
            }
            if ( $match_rule && $rule_line =~ /^\s*pool\s+\S+/i ) {
                $go_pool = $rule_line;
                $go_pool =~ s/^\s*pool\s+(\S+)\s*/$1/;
                last;
            }
        }
        return $go_pool if defined $go_pool;
    }
    # If not found
    return "";
}

#
# Parse the gateway forward rule to determine which virtual server
# is the request re-directed to.
#
sub parse_gateway_forward {
    my ( $gateway_server, $url_path, $envid ) = @_;
    my $parse_rules_command = "/nas/home/minjzhang/bin/parse_apigateway_forward -s $gateway_server -e $envid -j";
    my $parse_rules = `$parse_rules_command`; 
    my $gateway_forward_ref = from_json( $parse_rules );
    my $go_url = qw{};
    foreach my $key ( keys %{ $gateway_forward_ref } ) {
        my $forward_rule_pattern = $key;
        $forward_rule_pattern =~ s/\*$//;
        $forward_rule_pattern =~ s/\?$//;
        $forward_rule_pattern =~ s/\/$//;
        $forward_rule_pattern =~ s/{.*id.*}/[0-9]+/i;
        $forward_rule_pattern =~ s/{giftCardNumber}/[0-9]+/i;
        $forward_rule_pattern =~ s/{ccPanToken}/[A-Z0-9]+/i;
        $gateway_forward_ref->{ $key } = "null" if not defined $gateway_forward_ref->{ $key };
        $logger->debug( "[APIGW] Forward $forward_rule_pattern to $gateway_forward_ref->{ $key }" );
        if ( $url_path =~ "$forward_rule_pattern" ) {
            $go_url = $gateway_forward_ref->{ $key };
        }
    }
    return $go_url;
}

#
# Get the back end server based on virtual server.
#
sub get_backend_server {
    my ( $icontrols_ref, $envid, $protocol, $virtual_server, $url_path) = @_;
    my ( $icontrol, $virtual_server_on_f5 ) = find_virtual_server( $icontrols_ref, $envid, $protocol, $virtual_server);
    my @irules_on_f5 = get_vs_irules( $icontrol, $virtual_server_on_f5 );
    my $default_pool_on_f5 = get_vs_default_pool( $icontrol, $virtual_server_on_f5 );

    my $go_pool = $default_pool_on_f5;

    if ( scalar @irules_on_f5 > 0 && $url_path ne "" ) {
        my $temp_pool = parse_irule( $icontrol, \@irules_on_f5, $url_path );
        $go_pool = $temp_pool if $temp_pool ne "";
    }
    return ( $go_pool, $icontrol );
}

#
# Get the prameters from URL.
#
sub get_params_from_url {
    my ( $request_url ) = @_;
    my $protocol = 'http';

    # TODO when specify :8080
    if ( $request_url =~ "^http[s]?://" ) {
        $protocol = $request_url;
        $protocol =~ s"^(http[s]?)://.*"$1";
    }

    my $virtual_server = $request_url;
    $virtual_server =~ s"(http[s]?://)?([^/]*)(/.*)?"$2";
    my $url_path = $request_url;
    $url_path =~ s"(http[s]?://)?([^/]*)(/.*)?"$3";
    my $url_envid = $virtual_server;
    $url_envid =~ s".*\.(srw[deq][0-9]+)\.com"$1";

    if ( not defined $envid ) {
        $envid = $url_envid;
    }

    return ( $protocol, $virtual_server, $url_path, $url_envid );
}

#
# Main
#
my ( $protocol, $virtual_server, $url_path, $url_envid ) = get_params_from_url( $request_url );

if ( not defined $envid ) {
    $envid = $url_envid;
}

# List of internal and external bigip server.

my $go_pool = qw{};
my $icontrol = qw{};

if ( $virtual_server =~ /^api-dev\.srw[deq][0-9]+\.com/ ) {
    my $icontrol_gateway = get_special_icontrol( $url_envid, "apigateway" );
    my @icontrols = ( $icontrol_gateway );
    ( $go_pool, $icontrol ) = get_backend_server( \@icontrols, $url_envid, $protocol, $virtual_server, $url_path);
    my @members = get_env_pool_members( $icontrol, $go_pool );
    my $gateway_server = $members[0];
    $gateway_server =~ s/(.*):.*/$1/;
    $gateway_server = get_hostname_by_ip( $gateway_server );
    $logger->debug( "[APIGW] Go to $gateway_server.");
    my $go_url = parse_gateway_forward( $gateway_server, $url_path, $envid );
    ( $protocol, $virtual_server, $url_path, $url_envid ) = get_params_from_url( $go_url );
    @icontrols = get_icontrol( $envid );
    ( $go_pool, $icontrol ) = get_backend_server( \@icontrols, $envid, $protocol, $virtual_server, $url_path);
} else {
    my @icontrols = get_icontrol( $envid );
    ( $go_pool, $icontrol ) = get_backend_server( \@icontrols, $envid, $protocol, $virtual_server, $url_path);
}

my @pool_members = get_env_pool_members( $icontrol, $go_pool );
foreach my $pool_member ( @pool_members ) {
    if ( not $show_verbose ) {
        print get_hostname_by_ip( $pool_member ) . "\n";
    } else {
        $logger->info( "Go to " . get_hostname_by_ip( $pool_member ) );
    }
}

exit 0;
